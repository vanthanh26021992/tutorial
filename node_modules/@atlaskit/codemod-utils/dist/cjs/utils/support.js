"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addCommentBefore = addCommentBefore;
exports.addDynamicImport = exports.addCommentToStartOfFile = void 0;
exports.addToImport = addToImport;
exports.callExpressionArgMatchesString = void 0;
exports.clean = clean;
exports.getJSXAttributesByName = exports.getDynamicImportName = exports.getDefaultSpecifier = exports.doesIdentifierExist = exports.debug = void 0;
exports.getNamedSpecifier = getNamedSpecifier;
exports.getSafeImportName = getSafeImportName;
exports.isEmpty = exports.hasJSXAttributesByName = exports.hasImportDeclarationFromAnyPackageEntrypoint = exports.hasImportDeclaration = void 0;
exports.matchesStringWithFormatSpecifier = matchesStringWithFormatSpecifier;
exports.placeholderStringMatches = placeholderStringMatches;
exports.removeImport = removeImport;
exports.testMethodVariantEach = exports.shiftDefaultImport = void 0;
exports.tryCreateImport = tryCreateImport;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

function getNamedSpecifier(j, source, specifier, importName) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportSpecifier).filter(function (path) {
    return path.node.imported.name === importName;
  });

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}

var getDynamicImportName = function getDynamicImportName(j, source, importPath) {
  var dynamicImports = source.find(j.VariableDeclarator).filter(function (variableDeclaratorPath) {
    return j(variableDeclaratorPath).find(j.CallExpression).filter(function (callExpressionPath) {
      var _callExpressionPath$n = callExpressionPath.node,
          callee = _callExpressionPath$n.callee,
          callExpressionArguments = _callExpressionPath$n.arguments;
      return !!(isCallExpressionCalleeImportType(callee) && isCallExpressionArgumentStringLiteralType(callExpressionArguments) && isCallExpressionArgumentValueMatches(callExpressionArguments[0], j, importPath));
    }).length > 0;
  });

  if (!dynamicImports.length) {
    return null;
  }

  var id = dynamicImports.nodes()[0].id;

  if (id.type !== 'Identifier') {
    return null;
  }

  return id.name;
};

exports.getDynamicImportName = getDynamicImportName;

var isCallExpressionCalleeImportType = function isCallExpressionCalleeImportType(callee) {
  return callee && callee.type === 'Import';
};

var isCallExpressionArgumentStringLiteralType = function isCallExpressionArgumentStringLiteralType(callExpressionArguments) {
  return callExpressionArguments && callExpressionArguments.length && callExpressionArguments[0].type === 'StringLiteral';
};

var isCallExpressionArgumentValueMatches = function isCallExpressionArgumentValueMatches(callExpressionArgument, j, value) {
  return j(callExpressionArgument).some(function (path) {
    return path.node.value === value;
  });
};

var addDynamicImport = function addDynamicImport(j, target, name, packageEndpoint) {
  var node = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(name), j.callExpression(j.memberExpression(j.identifier('React'), j.identifier('lazy')), [j.arrowFunctionExpression([], j.callExpression(j.import(), [j.stringLiteral(packageEndpoint)]))]))]);
  target.insertAfter(node);
  addCommentBefore(j, j(node), 'We have added "React.lazy" here. Feel free to change it to "lazy" or other named import depending upon how you imported.');
}; // not replacing newlines (which \s does)


exports.addDynamicImport = addDynamicImport;
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;

function clean(value) {
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

var addCommentToStartOfFile = function addCommentToStartOfFile(_ref) {
  var j = _ref.j,
      base = _ref.base,
      message = _ref.message;
  addCommentBefore(j, base.find(j.Program), message);
};

exports.addCommentToStartOfFile = addCommentToStartOfFile;

function addCommentBefore(j, target, message) {
  var commentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'block';
  var messagePrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'TODO: (from codemod) ';
  var msg = clean(messagePrefix + message);
  var content = commentType === 'block' ? " ".concat(msg, " ") : " ".concat(msg);
  target.forEach(function (path) {
    path.value.comments = path.value.comments || [];
    var exists = path.value.comments.find(function (comment) {
      return comment.value === content;
    }); // avoiding duplicates of the same comment

    if (exists) {
      return;
    }

    if (commentType === 'block') {
      path.value.comments.push(j.commentBlock(content));
    } else {
      path.value.comments.push(j.commentLine(content));
    }
  });
}

var getDefaultSpecifier = function getDefaultSpecifier(j, source, specifier) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportDefaultSpecifier);

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}; // @ts-ignore


exports.getDefaultSpecifier = getDefaultSpecifier;

var getJSXAttributesByName = function getJSXAttributesByName(j, element, attributeName) {
  return j(element).find(j.JSXOpeningElement).at(0).find(j.JSXAttribute).filter(function (attribute) {
    var matches = j(attribute).find(j.JSXIdentifier).filter(function (identifier) {
      return identifier.value.name === attributeName;
    });
    return Boolean(matches.length);
  });
};

exports.getJSXAttributesByName = getJSXAttributesByName;

var isEmpty = function isEmpty(string) {
  return string && string.value !== '';
};

exports.isEmpty = isEmpty;

var hasImportDeclaration = function hasImportDeclaration(j, source, importPath) {
  var imports = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === importPath;
  });
  return Boolean(imports.length);
};

exports.hasImportDeclaration = hasImportDeclaration;

var hasImportDeclarationFromAnyPackageEntrypoint = function hasImportDeclarationFromAnyPackageEntrypoint(j, source, packageName) {
  var imports = source.find(j.ImportDeclaration).filter(function (path) {
    var _path$node, _path$node$source;

    return (// @ts-ignore
      path === null || path === void 0 ? void 0 : (_path$node = path.node) === null || _path$node === void 0 ? void 0 : (_path$node$source = _path$node.source) === null || _path$node$source === void 0 ? void 0 : _path$node$source.value.toString().startsWith(packageName)
    );
  });
  return Boolean(imports.length);
};

exports.hasImportDeclarationFromAnyPackageEntrypoint = hasImportDeclarationFromAnyPackageEntrypoint;

var debug = function debug(component) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      console.log(element); //eslint-disable-line no-console
    });
  };
};

exports.debug = debug;

function placeholderStringMatches(placeholderStr, resolvedStr) {
  if (placeholderStr === resolvedStr) {
    return true;
  }

  var value = '';
  var offset = 0;
  var partsPlaceholder = placeholderStr.split(' ');
  var partsResolved = resolvedStr.split(' ');
  partsPlaceholder.forEach(function (p, i) {
    // Placeholder
    if (p.startsWith('%')) {
      // Trim remaining words from current position to avoid premature matching from previous parts
      var remainingWords = partsResolved.slice(i + offset);
      var nextWordIndex = remainingWords.indexOf(partsPlaceholder[i + 1]);
      var hasNextWord = nextWordIndex !== -1;

      if (hasNextWord) {
        offset += nextWordIndex - 1;
      }

      var insert = remainingWords.slice(0, hasNextWord ? nextWordIndex : undefined).join(' ');
      value += "".concat(insert, " "); // Regular words
    } else {
      value += "".concat(p, " ");
    }
  });
  return value.trimRight() === resolvedStr;
}
/**
 * Check whether a value contains a Format Specifier (printf placeholder)
 *
 * @see https://jestjs.io/docs/api#testeachtablename-fn-timeout
 * @see https://nodejs.org/api/util.html#utilformatformat-args
 *
 * @param argValue The string potentially containing a format specifier (e.g. 'Foo %s')
 * @param str The string that has replaced a format specifier with a tangible value (e.g. 'Foo Bar`)
 *
 * @returns Boolean: True if the strings matched (after considering the placeholder), or false if not.
 */


function matchesStringWithFormatSpecifier(argValue, str) {
  var value = String(argValue); // Check whether value contains a printf format placeholder e.g. %s, %d etc

  if (value && value.match(/%(p|s|d|i|f|j|o|#)/g)) {
    return placeholderStringMatches(value, str);
  } else {
    // No format specifier placeholder
    return false;
  }
}

var checkForTemplateLiteralsWithPlaceholders = function checkForTemplateLiteralsWithPlaceholders(quasis, str) {
  var templateStrs = quasis.map(function (quasi) {
    return quasi.value.raw.trim();
  }).join('.*');
  var regex = new RegExp(templateStrs);
  return regex.test(str);
};

var callExpressionArgMatchesString = function callExpressionArgMatchesString(arg, str) {
  switch (arg.type) {
    case 'StringLiteral':
    case 'Literal':
      {
        if (arg.value === str) {
          return true;
        } else {
          // Eg: 'should contain %s'
          return matchesStringWithFormatSpecifier(arg.value, str);
        }
      }

    case 'TemplateLiteral':
      {
        // fuzzy match template literals, skipping expressions
        var templateStrs = arg.quasis.map(function (quasi) {
          return quasi.value.raw.trim();
        }).join(' ');

        if (str.trim() === templateStrs.trim()) {
          return true;
        } else {
          // Eg: `should contain ${value}`
          return checkForTemplateLiteralsWithPlaceholders(arg.quasis, str);
        }
      }

    case 'BinaryExpression':
      {
        return false;
      }

    default:
      {
        return false;
      }
  }
};

exports.callExpressionArgMatchesString = callExpressionArgMatchesString;

var testMethodVariantEach = function testMethodVariantEach(path, testMethods) {
  var _path$value, _path$value$callee, _path$value$callee$ca, _path$value2, _path$value2$callee, _path$value2$callee$c, _path$value2$callee$c2, _path$value3, _path$value3$callee, _path$value3$callee$c, _path$value3$callee$c2;

  var variants = new Set(['each']);
  return (// @ts-ignore
    ((_path$value = path.value) === null || _path$value === void 0 ? void 0 : (_path$value$callee = _path$value.callee) === null || _path$value$callee === void 0 ? void 0 : (_path$value$callee$ca = _path$value$callee.callee) === null || _path$value$callee$ca === void 0 ? void 0 : _path$value$callee$ca.type) === 'MemberExpression' && // @ts-ignore
    testMethods.has((_path$value2 = path.value) === null || _path$value2 === void 0 ? void 0 : (_path$value2$callee = _path$value2.callee) === null || _path$value2$callee === void 0 ? void 0 : (_path$value2$callee$c = _path$value2$callee.callee) === null || _path$value2$callee$c === void 0 ? void 0 : (_path$value2$callee$c2 = _path$value2$callee$c.object) === null || _path$value2$callee$c2 === void 0 ? void 0 : _path$value2$callee$c2.name) && // @ts-ignore
    variants.has((_path$value3 = path.value) === null || _path$value3 === void 0 ? void 0 : (_path$value3$callee = _path$value3.callee) === null || _path$value3$callee === void 0 ? void 0 : (_path$value3$callee$c = _path$value3$callee.callee) === null || _path$value3$callee$c === void 0 ? void 0 : (_path$value3$callee$c2 = _path$value3$callee$c.property) === null || _path$value3$callee$c2 === void 0 ? void 0 : _path$value3$callee$c2.name)
  );
};

exports.testMethodVariantEach = testMethodVariantEach;

var hasJSXAttributesByName = function hasJSXAttributesByName(j, element, attributeName) {
  return getJSXAttributesByName(j, element, attributeName).length > 0;
};

exports.hasJSXAttributesByName = hasJSXAttributesByName;

var doesIdentifierExist = function doesIdentifierExist(j, base, name) {
  return base.find(j.Identifier).filter(function (identifer) {
    return identifer.value.name === name;
  }).length > 0;
};

exports.doesIdentifierExist = doesIdentifierExist;

function removeImport(j, base, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === packageName;
  }).remove();
}

function tryCreateImport(j, base, relativeToPackage, packageName, shouldBeTypeImport) {
  var matches = base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  });
  var exists = matches.length > 0;

  if (exists) {
    if (shouldBeTypeImport) {
      // if the matched import declarations are not type imports
      // but should be, we update them accordingly
      var isTypeImports = matches.every(function (path) {
        return path.value.importKind === 'type';
      });

      if (!isTypeImports) {
        matches.filter(function (path) {
          return path.value.importKind !== 'type';
        }).forEach(function (path) {
          path.value.importKind = 'type';
        });
        return;
      }
    }

    return;
  } // we dynamically build up importDeclaration args, so that if shouldBeTypeImport
  // is falsy, it is never passed explicitly as an importKind parameter (avoiding
  // runtime exceptions during transform runs when importKind is undefined)


  var importDeclarationArgs = [[], j.literal(packageName)];

  if (shouldBeTypeImport) {
    importDeclarationArgs.push('type');
  }

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === relativeToPackage;
  }) // we only take the first matching path, to avoid duplicate inserts
  // if the source contains the same import declaration more than once
  .paths()[0].insertBefore(j.importDeclaration.apply(j, importDeclarationArgs));
}

function addToImport(j, base, importSpecifier, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  }).at(0).replaceWith(function (declaration) {
    return j.importDeclaration([].concat((0, _toConsumableArray2.default)((declaration.value.specifiers || []).filter(function (item) {
      return item.type === 'ImportSpecifier' && item.imported != null;
    })), [importSpecifier]), j.literal(packageName), declaration.value.importKind);
  });
}

var shiftDefaultImport = function shiftDefaultImport(j, base, defaultName, oldPackagePath, newPackagePath) {
  tryCreateImport(j, base, oldPackagePath, newPackagePath);
  addToImport(j, base, j.importDefaultSpecifier(j.identifier(defaultName)), newPackagePath); // removing old default specifier

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === oldPackagePath;
  }).remove();
};

exports.shiftDefaultImport = shiftDefaultImport;

function getSafeImportName(_ref2) {
  var j = _ref2.j,
      base = _ref2.base,
      currentDefaultSpecifierName = _ref2.currentDefaultSpecifierName,
      desiredName = _ref2.desiredName,
      fallbackName = _ref2.fallbackName;

  if (currentDefaultSpecifierName === desiredName) {
    return desiredName;
  }

  var isUsed = doesIdentifierExist(j, base, desiredName);
  return isUsed ? fallbackName : desiredName;
}