function getNamedSpecifier(j, source, specifier, importName) {
  const specifiers = source.find(j.ImportDeclaration).filter(path => path.node.source.value === specifier).find(j.ImportSpecifier).filter(path => path.node.imported.name === importName);

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}

const getDynamicImportName = (j, source, importPath) => {
  const dynamicImports = source.find(j.VariableDeclarator).filter(variableDeclaratorPath => {
    return j(variableDeclaratorPath).find(j.CallExpression).filter(callExpressionPath => {
      const {
        callee,
        arguments: callExpressionArguments
      } = callExpressionPath.node;
      return !!(isCallExpressionCalleeImportType(callee) && isCallExpressionArgumentStringLiteralType(callExpressionArguments) && isCallExpressionArgumentValueMatches(callExpressionArguments[0], j, importPath));
    }).length > 0;
  });

  if (!dynamicImports.length) {
    return null;
  }

  const {
    id
  } = dynamicImports.nodes()[0];

  if (id.type !== 'Identifier') {
    return null;
  }

  return id.name;
};

const isCallExpressionCalleeImportType = callee => {
  return callee && callee.type === 'Import';
};

const isCallExpressionArgumentStringLiteralType = callExpressionArguments => {
  return callExpressionArguments && callExpressionArguments.length && callExpressionArguments[0].type === 'StringLiteral';
};

const isCallExpressionArgumentValueMatches = (callExpressionArgument, j, value) => {
  return j(callExpressionArgument).some(path => path.node.value === value);
};

const addDynamicImport = (j, target, name, packageEndpoint) => {
  const node = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(name), j.callExpression(j.memberExpression(j.identifier('React'), j.identifier('lazy')), [j.arrowFunctionExpression([], j.callExpression(j.import(), [j.stringLiteral(packageEndpoint)]))]))]);
  target.insertAfter(node);
  addCommentBefore(j, j(node), 'We have added "React.lazy" here. Feel free to change it to "lazy" or other named import depending upon how you imported.');
}; // not replacing newlines (which \s does)


const spacesAndTabs = /[ \t]{2,}/g;
const lineStartWithSpaces = /^[ \t]*/gm;

function clean(value) {
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

const addCommentToStartOfFile = ({
  j,
  base,
  message
}) => {
  addCommentBefore(j, base.find(j.Program), message);
};

function addCommentBefore(j, target, message, commentType = 'block', messagePrefix = 'TODO: (from codemod) ') {
  const msg = clean(messagePrefix + message);
  const content = commentType === 'block' ? ` ${msg} ` : ` ${msg}`;
  target.forEach(path => {
    path.value.comments = path.value.comments || [];
    const exists = path.value.comments.find(comment => comment.value === content); // avoiding duplicates of the same comment

    if (exists) {
      return;
    }

    if (commentType === 'block') {
      path.value.comments.push(j.commentBlock(content));
    } else {
      path.value.comments.push(j.commentLine(content));
    }
  });
}

const getDefaultSpecifier = (j, source, specifier) => {
  const specifiers = source.find(j.ImportDeclaration).filter(path => path.node.source.value === specifier).find(j.ImportDefaultSpecifier);

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}; // @ts-ignore


const getJSXAttributesByName = (j, element, attributeName) => {
  return j(element).find(j.JSXOpeningElement).at(0).find(j.JSXAttribute).filter(attribute => {
    const matches = j(attribute).find(j.JSXIdentifier).filter(identifier => identifier.value.name === attributeName);
    return Boolean(matches.length);
  });
};

const isEmpty = string => string && string.value !== '';

const hasImportDeclaration = (j, source, importPath) => {
  const imports = source.find(j.ImportDeclaration).filter(path => path.node.source.value === importPath);
  return Boolean(imports.length);
};

const hasImportDeclarationFromAnyPackageEntrypoint = (j, source, packageName) => {
  const imports = source.find(j.ImportDeclaration).filter(path => {
    var _path$node, _path$node$source;

    return (// @ts-ignore
      path === null || path === void 0 ? void 0 : (_path$node = path.node) === null || _path$node === void 0 ? void 0 : (_path$node$source = _path$node.source) === null || _path$node$source === void 0 ? void 0 : _path$node$source.value.toString().startsWith(packageName)
    );
  });
  return Boolean(imports.length);
};

const debug = component => (j, source) => {
  const defaultSpecifier = getDefaultSpecifier(j, source, component);

  if (!defaultSpecifier) {
    return;
  }

  source.findJSXElements(defaultSpecifier).forEach(element => {
    console.log(element); //eslint-disable-line no-console
  });
};

export function placeholderStringMatches(placeholderStr, resolvedStr) {
  if (placeholderStr === resolvedStr) {
    return true;
  }

  let value = '';
  let offset = 0;
  const partsPlaceholder = placeholderStr.split(' ');
  const partsResolved = resolvedStr.split(' ');
  partsPlaceholder.forEach((p, i) => {
    // Placeholder
    if (p.startsWith('%')) {
      // Trim remaining words from current position to avoid premature matching from previous parts
      const remainingWords = partsResolved.slice(i + offset);
      const nextWordIndex = remainingWords.indexOf(partsPlaceholder[i + 1]);
      const hasNextWord = nextWordIndex !== -1;

      if (hasNextWord) {
        offset += nextWordIndex - 1;
      }

      const insert = remainingWords.slice(0, hasNextWord ? nextWordIndex : undefined).join(' ');
      value += `${insert} `; // Regular words
    } else {
      value += `${p} `;
    }
  });
  return value.trimRight() === resolvedStr;
}
/**
 * Check whether a value contains a Format Specifier (printf placeholder)
 *
 * @see https://jestjs.io/docs/api#testeachtablename-fn-timeout
 * @see https://nodejs.org/api/util.html#utilformatformat-args
 *
 * @param argValue The string potentially containing a format specifier (e.g. 'Foo %s')
 * @param str The string that has replaced a format specifier with a tangible value (e.g. 'Foo Bar`)
 *
 * @returns Boolean: True if the strings matched (after considering the placeholder), or false if not.
 */

export function matchesStringWithFormatSpecifier(argValue, str) {
  const value = String(argValue); // Check whether value contains a printf format placeholder e.g. %s, %d etc

  if (value && value.match(/%(p|s|d|i|f|j|o|#)/g)) {
    return placeholderStringMatches(value, str);
  } else {
    // No format specifier placeholder
    return false;
  }
}

const checkForTemplateLiteralsWithPlaceholders = (quasis, str) => {
  const templateStrs = quasis.map(quasi => quasi.value.raw.trim()).join('.*');
  let regex = new RegExp(templateStrs);
  return regex.test(str);
};

const callExpressionArgMatchesString = (arg, str) => {
  switch (arg.type) {
    case 'StringLiteral':
    case 'Literal':
      {
        if (arg.value === str) {
          return true;
        } else {
          // Eg: 'should contain %s'
          return matchesStringWithFormatSpecifier(arg.value, str);
        }
      }

    case 'TemplateLiteral':
      {
        // fuzzy match template literals, skipping expressions
        const templateStrs = arg.quasis.map(quasi => {
          return quasi.value.raw.trim();
        }).join(' ');

        if (str.trim() === templateStrs.trim()) {
          return true;
        } else {
          // Eg: `should contain ${value}`
          return checkForTemplateLiteralsWithPlaceholders(arg.quasis, str);
        }
      }

    case 'BinaryExpression':
      {
        return false;
      }

    default:
      {
        return false;
      }
  }
};

const testMethodVariantEach = (path, testMethods) => {
  var _path$value, _path$value$callee, _path$value$callee$ca, _path$value2, _path$value2$callee, _path$value2$callee$c, _path$value2$callee$c2, _path$value3, _path$value3$callee, _path$value3$callee$c, _path$value3$callee$c2;

  const variants = new Set(['each']);
  return (// @ts-ignore
    ((_path$value = path.value) === null || _path$value === void 0 ? void 0 : (_path$value$callee = _path$value.callee) === null || _path$value$callee === void 0 ? void 0 : (_path$value$callee$ca = _path$value$callee.callee) === null || _path$value$callee$ca === void 0 ? void 0 : _path$value$callee$ca.type) === 'MemberExpression' && // @ts-ignore
    testMethods.has((_path$value2 = path.value) === null || _path$value2 === void 0 ? void 0 : (_path$value2$callee = _path$value2.callee) === null || _path$value2$callee === void 0 ? void 0 : (_path$value2$callee$c = _path$value2$callee.callee) === null || _path$value2$callee$c === void 0 ? void 0 : (_path$value2$callee$c2 = _path$value2$callee$c.object) === null || _path$value2$callee$c2 === void 0 ? void 0 : _path$value2$callee$c2.name) && // @ts-ignore
    variants.has((_path$value3 = path.value) === null || _path$value3 === void 0 ? void 0 : (_path$value3$callee = _path$value3.callee) === null || _path$value3$callee === void 0 ? void 0 : (_path$value3$callee$c = _path$value3$callee.callee) === null || _path$value3$callee$c === void 0 ? void 0 : (_path$value3$callee$c2 = _path$value3$callee$c.property) === null || _path$value3$callee$c2 === void 0 ? void 0 : _path$value3$callee$c2.name)
  );
};

const hasJSXAttributesByName = (j, element, attributeName) => getJSXAttributesByName(j, element, attributeName).length > 0;

const doesIdentifierExist = (j, base, name) => {
  return base.find(j.Identifier).filter(identifer => identifer.value.name === name).length > 0;
};

function removeImport(j, base, packageName) {
  base.find(j.ImportDeclaration).filter(path => path.node.source.value === packageName).remove();
}

function tryCreateImport(j, base, relativeToPackage, packageName, shouldBeTypeImport) {
  const matches = base.find(j.ImportDeclaration).filter(path => path.value.source.value === packageName);
  const exists = matches.length > 0;

  if (exists) {
    if (shouldBeTypeImport) {
      // if the matched import declarations are not type imports
      // but should be, we update them accordingly
      const isTypeImports = matches.every(path => path.value.importKind === 'type');

      if (!isTypeImports) {
        matches.filter(path => path.value.importKind !== 'type').forEach(path => {
          path.value.importKind = 'type';
        });
        return;
      }
    }

    return;
  } // we dynamically build up importDeclaration args, so that if shouldBeTypeImport
  // is falsy, it is never passed explicitly as an importKind parameter (avoiding
  // runtime exceptions during transform runs when importKind is undefined)


  const importDeclarationArgs = [[], j.literal(packageName)];

  if (shouldBeTypeImport) {
    importDeclarationArgs.push('type');
  }

  base.find(j.ImportDeclaration).filter(path => path.value.source.value === relativeToPackage) // we only take the first matching path, to avoid duplicate inserts
  // if the source contains the same import declaration more than once
  .paths()[0].insertBefore(j.importDeclaration(...importDeclarationArgs));
}

function addToImport(j, base, importSpecifier, packageName) {
  base.find(j.ImportDeclaration).filter(path => path.value.source.value === packageName).at(0).replaceWith(declaration => {
    return j.importDeclaration([// we are appending to the existing specifiers
    // We are doing a filter hear because sometimes specifiers can be removed
    // but they hand around in the declaration
    ...(declaration.value.specifiers || []).filter(item => item.type === 'ImportSpecifier' && item.imported != null), importSpecifier], j.literal(packageName), declaration.value.importKind);
  });
}

const shiftDefaultImport = (j, base, defaultName, oldPackagePath, newPackagePath) => {
  tryCreateImport(j, base, oldPackagePath, newPackagePath);
  addToImport(j, base, j.importDefaultSpecifier(j.identifier(defaultName)), newPackagePath); // removing old default specifier

  base.find(j.ImportDeclaration).filter(path => path.node.source.value === oldPackagePath).remove();
};

function getSafeImportName({
  j,
  base,
  currentDefaultSpecifierName,
  desiredName,
  fallbackName
}) {
  if (currentDefaultSpecifierName === desiredName) {
    return desiredName;
  }

  const isUsed = doesIdentifierExist(j, base, desiredName);
  return isUsed ? fallbackName : desiredName;
}

export { getDefaultSpecifier, getNamedSpecifier, getJSXAttributesByName, hasJSXAttributesByName, hasImportDeclaration, hasImportDeclarationFromAnyPackageEntrypoint, addCommentBefore, addCommentToStartOfFile, doesIdentifierExist, removeImport, tryCreateImport, addToImport, shiftDefaultImport, isEmpty, clean, debug, callExpressionArgMatchesString, testMethodVariantEach, getSafeImportName, getDynamicImportName, addDynamicImport };