import core, { ASTPath, CallExpression, ImportDeclaration, ImportDefaultSpecifier, ImportSpecifier, JSXAttribute, JSXElement, Program, VariableDeclaration, VariableDeclarator } from 'jscodeshift';
import { Collection } from 'jscodeshift/src/Collection';
declare function getNamedSpecifier(j: core.JSCodeshift, source: Collection<Node>, specifier: string, importName: string): string | null;
declare const getDynamicImportName: (j: core.JSCodeshift, source: Collection<any>, importPath: string) => string | null;
declare const addDynamicImport: (j: core.JSCodeshift, target: Collection<VariableDeclaration>, name: string, packageEndpoint: string) => void;
declare function clean(value: string): string;
declare const addCommentToStartOfFile: ({ j, base, message, }: {
    j: core.JSCodeshift;
    base: Collection<Node>;
    message: string;
}) => void;
declare function addCommentBefore(j: core.JSCodeshift, target: Collection<Program> | Collection<ImportDeclaration> | Collection<JSXElement> | Collection<JSXAttribute> | Collection<CallExpression> | Collection<VariableDeclarator>, message: string, commentType?: 'block' | 'line', messagePrefix?: string): void;
declare const getDefaultSpecifier: (j: core.JSCodeshift, source: Collection<Node>, specifier: string) => string | null;
declare const getJSXAttributesByName: (j: core.JSCodeshift, element: ASTPath<any>, attributeName: string) => Collection<JSXAttribute>;
declare const isEmpty: any;
declare const hasImportDeclaration: (j: core.JSCodeshift, source: Collection<Node>, importPath: string) => boolean;
declare const hasImportDeclarationFromAnyPackageEntrypoint: (j: core.JSCodeshift, source: Collection<Node>, packageName: string) => boolean;
declare const debug: (component: string) => (j: core.JSCodeshift, source: Collection<Node>) => void;
export declare function placeholderStringMatches(placeholderStr: string, resolvedStr: string): boolean;
/**
 * Check whether a value contains a Format Specifier (printf placeholder)
 *
 * @see https://jestjs.io/docs/api#testeachtablename-fn-timeout
 * @see https://nodejs.org/api/util.html#utilformatformat-args
 *
 * @param argValue The string potentially containing a format specifier (e.g. 'Foo %s')
 * @param str The string that has replaced a format specifier with a tangible value (e.g. 'Foo Bar`)
 *
 * @returns Boolean: True if the strings matched (after considering the placeholder), or false if not.
 */
export declare function matchesStringWithFormatSpecifier(argValue: string | number | boolean | RegExp | null, str: string): boolean;
declare const callExpressionArgMatchesString: (arg: CallExpression['arguments'][number], str: string) => boolean;
declare const testMethodVariantEach: (path: ASTPath<CallExpression>, testMethods: Set<string>) => boolean;
declare const hasJSXAttributesByName: (j: core.JSCodeshift, element: ASTPath<any>, attributeName: string) => boolean;
declare const doesIdentifierExist: (j: core.JSCodeshift, base: Collection<any>, name: string) => boolean;
declare function removeImport(j: core.JSCodeshift, base: Collection<any>, packageName: string): void;
declare function tryCreateImport(j: core.JSCodeshift, base: Collection<any>, relativeToPackage: string, packageName: string, shouldBeTypeImport?: boolean): void;
declare function addToImport(j: core.JSCodeshift, base: Collection<any>, importSpecifier: ImportSpecifier | ImportDefaultSpecifier, packageName: string): void;
declare const shiftDefaultImport: (j: core.JSCodeshift, base: Collection<any>, defaultName: string, oldPackagePath: string, newPackagePath: string) => void;
declare function getSafeImportName({ j, base, currentDefaultSpecifierName, desiredName, fallbackName, }: {
    j: core.JSCodeshift;
    base: Collection<any>;
    currentDefaultSpecifierName: string | null;
    desiredName: string;
    fallbackName: string;
}): string;
export { getDefaultSpecifier, getNamedSpecifier, getJSXAttributesByName, hasJSXAttributesByName, hasImportDeclaration, hasImportDeclarationFromAnyPackageEntrypoint, addCommentBefore, addCommentToStartOfFile, doesIdentifierExist, removeImport, tryCreateImport, addToImport, shiftDefaultImport, isEmpty, clean, debug, callExpressionArgMatchesString, testMethodVariantEach, getSafeImportName, getDynamicImportName, addDynamicImport, };
